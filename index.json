[
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/image-analysis/",
	"title": "Drop Shape analysis using Python",
	"tags": [],
	"description": "Tutorial for drop shape detection and analysis.",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n This tutorial proposes a way of analyzing an image of a drop on a SLIPS surface. At the end of it, we will have gathered the important characteristics of the drop:\n its edge its base radius the position of the triple (oil-drop-vapor) point the apparent contact angles  Installing the needed packages Basic packages During this tutorial, we will need several python packages that has to be installed on your environment. The majority of the needed packages can be installed from PyPI using the following command:\npip install imageio matplotlib numpy scipy Or for conda users:\nconda install imageio matplotlib numpy scipy OpenCV We will also need OpenCV to be installed. For conda users on windows, you should be able to get this working with the following command:\nconda install opencv Or this one:\nconda install -c menpo opencv For Linux users, get OpenCV from your distribution repository or build it from source.\nImporting images Imageio package allows to import and export a variety of image formats (see here for an exhaustive list).\nImageio can also import videos or grab images directly from cameras.\nimport imageio image = imageio.imread(\u0026#39;data/image.bmp\u0026#39;)   Explain me this block    We first imports the Imageio module.\nThen use its imread() function to read the image and store it in the image variable.\n   Images are stored as arrays of numbers. We can display them using the matplotlib package:\nimport matplotlib.pyplot as plt plt.figure() plt.imshow(image) plt.colorbar() plt.show()   Explain me this block    We first imports the pyplot submodule from matplotlib. The Pyplot module is the main submodule for plotting data in a Matlab-way.\nWe then create a figure with plt.figure(), display the image in it with plt.imshow(), add a colorbar with plt.colorbar() and show the results with plt.show().\nDepending on your IDE, you may not need the last line, as the figures will automatically be shown.\n   Cropping The drop is centered on the image, but a part of the syringe that was used to drop it is also visible at the top.\nAn edge detection performed directly on this image will certainly detect the syringe edges. To avoid that, we will restrain the area of interest around the drop.\nimage = image[200:400, 200:550] # Display plt.figure() plt.imshow(image) plt.show()    Explain me this block    The image variable is an array of numbers that can be cropped using indexes. It is here cropped from indexes 200 to 550 on the x axis and from indexes 200 to 400 on the y axis. Because of the way images are referenced by the Imageio and matplotlib packages, the y axis has to be specified first.\nWe then display the image.\n   Edge detection OpenCV (Open Source Computer Vision Library) is a well-known library for image analysis that provides a Python interface. We will use one of its edge detection functions to get the edge of our drop. More specifically, we will use the Canny edge detector.\nThis edge detector method necessitates to specify two threshold values, that have to be optimized depending on the nature/quality of the edges to detect. A first good guess is generally to take the minimal and maximal pixel values as thresholds.\nimport cv2 thres1 = image.min() thres2 = image.max() edges = cv2.Canny(image, thres1, thres2) # Display the edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    We import opencv with import cv2.\nMinimal and maximal pixel values are obtained using the min() and max() methods and stored.\nThose values are then used as arguments of the OpenCV edge detector: Canny().\nThe result is an array of numbers, stored in the edges variable.\nThis array of numbers id finally displayed.\n   The Canny() function returns an array of numbers that is equal to 1 (in yellow here) where edges have been detected, and 0 (in blue here) elsewhere.\nOpenCV successfully detects the drop edges, but also some structures near the sample surface. Lets improve the threshold values to get rid of those unwanted bits.\nSome methods, like the Otsu method, can be used to automatically infers good threshold values from an image. thres1 = image.min()*0.75 thres2 = image.max()*1.5 edges = cv2.Canny(image, thres1, thres2) # Display the edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    This block is mainly similar to the previous one.\nThe threshold values are just adjusted to get rid of the unwanted edges near the sample surface. The thresholds values are now 0.75 times the minimal pixel value and 1.5 times the maximal pixel value.\n   We got rid of some of the unwanted bits, but we still detect some weird shapes due to the reflection of the drop on the sample (around x=50, y=200 for example). We can remove them by deleting all the edges detected below the baseline, that is here roughly y=180.\nedges[180:, :] = 0 # Display the edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    edges is an array containing 1 where edges were detected and 0 elsewhere. To remove edges for y\u0026lt;180, we just need to fill the array with 0 for y\u0026lt;180.\nThis is done by specifying that the values of edges from y=180 to infinity (180:) and for every x (:) are set to 0.\n   From image to points Our drop edge is for the moment stored as an array of 0 and 1. If we want to access the edge coordinates, we need to find the positions of each pixel equal to 1 (yellow pixels here).\nThe numpy package can help us do that by detecting where the pixel values are not zero.\nimport numpy as np ys, xs = np.where(edges) ys = np.asarray(-ys, dtype=float) xs = np.asarray(xs, dtype=float) # Display the edges plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show()   Explain me this block    We import numpy with import numpy as np.\nThe np.where() function returns the positions of the array that are not equal to zero. Which are here the positions of our drop edge.\nThe two following lines allow to transform the position from integers to floating point values. This will be needed for the next steps.\nplt.plot() allows to plot the edge points position.\nplt.axis('equal') ensures that the image is not deformed (stretched) along x or y.\n   For convenience, we want to center the drop on the referential.\nxs = xs - xs.mean() ys = ys - ys.min() # Plot the edges plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show()   Explain me this block    xs.mean() allows to access the average position of the edges along x.\nys.min() allows to access the minimal position of the edges along y.\nBy substracting those values to x and y, we ensure that the origin of our referential is at the base of the drop.\n   From pixels to mm We achieved to get the edge coordinated in pixel. To pass this information into millimeters, we need to know the ratio between pixels and mm for our base image.\nIt can be done by measuring the syringe diameter (here ~60 pixels) that we know is about 0.5mm. This gives us a resolution of 120px/mm.\nWe can now scale our edge coordinates:\nres = 120 xs /= res ys /= res # Plot the edge fig, axs = plt.subplots(1, 2, figsize=(10, 4)) plt.sca(axs[0]) plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.ylabel(\u0026#39;y [mm]\u0026#39;) # Plot a zoom on the edge plt.sca(axs[1]) plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.xlim(-1.15, -0.9) plt.ylim(-0.05, 0.3) plt.title(\u0026#34;Zoom\u0026#34;) plt.show() Fitting the edge Problem with the edge coordinates we obtained at this point is that they are at discrete positions (because extracted from an image). It is impossible to obtain contact angles or triple point position from this kind of discretized data. In order to go further, we need to find a good fitting of the drop edge.\nThe Scipy package provides several ways of fitting different kind of data. Here, as we don\u0026rsquo;t care about the mathematical expression of our fitting, we will use a spline fitting: UnivariateSpline.\nThis fitting function needs the data to be sorted and with strictly increasing x values. Our edge coordinated need some transformation to fit those specifications.\n# Ensure increasing x values new_xs = np.sort(list(set(xs))) new_ys = [] for x in new_xs: new_ys.append(np.mean(ys[xs == x])) xs = new_xs ys = np.asarray(new_ys) # Fitting the drop edge import scipy.interpolate as spint edge_f = spint.UnivariateSpline(xs, ys, k=5, s=0.005) # Display the fit fig, axs = plt.subplots(1, 2, figsize=(10, 4)) plt.sca(axs[0]) plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.plot(xs, edge_f(xs)) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.ylabel(\u0026#39;y [mm]\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) # Plot a zoom on the edge plt.sca(axs[1]) plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.plot(xs, edge_f(xs)) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.xlim(-1.1, -0.7) plt.ylim(0, 0.5) plt.title(\u0026#34;Zoom\u0026#34;) plt.show()   Explain me this block    We first sort the drop edges position along x and put them in the new_xs variable.\nThen, for each value of x, we average the associated values of y, to ensure that there is only one value of y for each x.\nWe then perform the fitting using the UnivariateSpline function from Scipy.\nk and s parameters can be tuned to achieve smoother or more accurate fitting.\nWe then display the edge and its fitting.\n   Getting the drop basic properties We can now extract some information from our data, like the drop base length or the drop height:\nbase_radius = xs.max() - xs.min() height = ys.max() # Print print(\u0026#34;Drop base: {} mm\u0026#34;.format(base_radius)) print(\u0026#34;Drop height: {} mm\u0026#34;.format(height)) Drop base: 2.091666666666667 mm Drop height: 0.85 mm  Getting the contact angles The contact angles are the angles made by our fitted curve and the baseline (here y=0).\n# Get left and right contact points left_x = np.min(xs) right_x = np.max(xs) dx = (right_x - left_x)/100 # Left angle import scipy.misc as spmisc deriv = spmisc.derivative(edge_f, left_x, dx=dx) theta_left = np.arctan(deriv) # Right angle deriv = spmisc.derivative(edge_f, right_x, dx=dx) theta_right = np.pi + np.arctan(deriv) # Print print(theta_left/np.pi*180) print(theta_right/np.pi*180) # Display the fit and the angles plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.plot(xs, edge_f(xs)) plt.axhline(0, color=\u0026#39;k\u0026#39;) angle_len = .6 plt.plot([left_x, left_x + angle_len*np.cos(theta_left)], [edge_f(left_x), edge_f(left_x) + angle_len*np.sin(theta_left)]) plt.plot([right_x, right_x + angle_len*np.cos(theta_right)], [edge_f(right_x), edge_f(right_x) + angle_len*np.sin(theta_right)]) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.ylabel(\u0026#39;y [mm]\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show() 74.74264462928066 105.21597243751776    Explain me this block    We first determine the positions of the drop edge contact with the baseline along x.\nWe then use the derivative function from Scipy to get the edge local slope at each contacts using our fitting.\ndx is used by the derivation algorithm. you can use a smaller value to get a more accurate result.\nThe edge local gradients are then translated to angles.\nWe then print and display the contact angles.\n   Getting the triple point Coming soon\u0026hellip;\n"
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/pydsa/",
	"title": "Drop Shape analysis using pyDSA (image)",
	"tags": [],
	"description": "Tutorial for drop shape analysis using pyDSA on a single image.",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n pyDSA is a python3 package for Drop Shape Analysis.\nInstalling pyDSA Dependencies You will first need to install IMTreatment by downloading the package here, extracting it and installing it with:\npython3 setup.py install pyDSA also use OpenCV for edge detection, so you will need it installed as well.\nInstall pyDSA Download the sources here, extract, and install them:\npython3 setup.py install pyDSA have some dependencies (matplotlib, scipy, numpy, \u0026hellip;) that should be installed automatically.\nImporting an image import pyDSA as dsa import matplotlib.pyplot as plt # Import an image im = dsa.import_from_image(\u0026#39;data/image.bmp\u0026#39;, dx=1/120, dy=1/120, unit_x=\u0026#39;mm\u0026#39;, unit_y=\u0026#39;mm\u0026#39;) # Display it plt.figure() im.display() plt.show() Focusing on the drop im.crop(intervx=[1.5, 5], intervy=[1, 3], inplace=True) # Display plt.figure() im.display() plt.show() Setting the baseline pyDSA provides an interactive function im.choose_baseline() to interactively set the baseline. It will display the drop image and ask you to put baseline points by clicking on the image.\nHere, we are gonna use the non-interactive function im.set_baseline() to set the baseline.\nim.set_baseline(pt1=[2, 1.61], pt2=[4.5, 1.61]) # DisplayF plt.figure() im.display() plt.show() The baseline is automatically displayed as a green line on the drop image.\nDetecting the edges The drop edge is detected using the Canny edge detection algorithm from OpenCV.\nedge = im.edge_detection() # Display the edge plt.figure() edge.display() plt.show() If the edge detection is not good enough, the edge_detection function provides several optional arguments that can help you get the edges you want. Please refer to the inline documentation of this function if you want to know more about this.\nFitting the edge Computing the contact angles will necessitates the edges to be fitted by a curve of some kind. pyDSA uses a spline fitting to achieve this.\nThe parameter s can be tuned to adapt the fitting: small values of s means a more accurate fitting, and bigger values of s a smoother fitting.\nedge.fit(s=0.0005) # Display the edge plt.figure() edge.display() plt.show() The edge fitting is displayed in orange.\nDetecting the triple points In the case of a SLIPS surface, pyDSA can detect the triple points of contact between the oil, water and air (e.g. the ridge top). This is done by detecting the point of inflexion of the edge line.\nedge.detect_triple_points() # Display the edge plt.figure() edge.display() plt.show() The triple points are displayed in purple.\nComputing the contact angles pyDSA uses the edge fitting to compute two kind of contact angles: - the contact angles between the drop and the baseline. - the apparent contact angles at the triple point (if a triple point is present).\nedge.compute_contact_angle() print(\u0026#39;Contact angles: {}\u0026#39;.format(edge.thetas)) print(\u0026#39;Triple point angles: {}\u0026#39;.format(edge.thetas_triple)) # Display the edge fig, axs = plt.subplots(1, 2, figsize=(10, 4)) plt.sca(axs[0]) edge.display() plt.axis(\u0026#39;equal\u0026#39;) plt.ylim(1.5, 3) # Zoom plt.sca(axs[1]) edge.display() plt.axis(\u0026#39;equal\u0026#39;) plt.ylim(1.5, 2) plt.xlim(2, 2.3) plt.show() Contact angles: [48.90734602702736, 126.40314516490614] Triple point angles: [81.4670191340014, 96.86878969719106]  Full script The whole process can be concentrated in a few lines of code, that allow to get from the drop image to the contact angles:\nimport pyDSA as dsa import matplotlib.pyplot as plt im = dsa.import_from_image(\u0026#39;data/image.bmp\u0026#39;, dx=1/120, dy=1/120, unit_x=\u0026#39;mm\u0026#39;, unit_y=\u0026#39;mm\u0026#39;) im.crop(intervx=[1.5, 5], intervy=[1, 3], inplace=True) im.set_baseline([2, 1.61], [4.5, 1.61]) edge = im.edge_detection() edge.fit(s=0.0005) edge.detect_triple_points() edge.compute_contact_angle() # Display the edge plt.figure(figsize=(20, 8)) edge.display() im.display() plt.show() Dealing with videos pyDSA can directly import videos and automatically analyze them in batch. This is the subject of the next tutorial, available here.\nHow does it works ? If you want to know more about how pyDSA works, you can take a look at the drop shape analysis tutorial, or go through the code (on your machine, or here).\n"
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/pydsa_video/",
	"title": "Drop Shape analysis using pyDSA (video)",
	"tags": [],
	"description": "Tutorial for drop shape analysis using pyDSA on a video.",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n It is recommended to read the tutorial on using pyDSA on a single image before doing this tutorial. This tutorial presents how to use pyDSA to analyze videos of drops. The video used is a side-view of a drop during an inflation-deflation sequence.\nImporting a video Importing works in the same way than for an image.\nImporting images in Python can easily fill your memory, you can import only some images of the video by using the incr argument. import pyDSA as dsa import matplotlib.pyplot as plt # Import an image ims = dsa.import_from_video(\u0026#39;data/video.mp4\u0026#39;, dx=1/120, dy=1/120, dt=1/10, unit_x=\u0026#39;mm\u0026#39;, unit_y=\u0026#39;mm\u0026#39;, unit_t=\u0026#39;s\u0026#39;, incr=10) # Display ims.display() plt.show() Detecting the edges and contact angles The method is similar than for a single image: we set the baseline, detect the edges, fit the edges, and compute the contact angles.\nims.set_baseline([0.0, 0.583], [6.492, 0.57]) edges = ims.edge_detection() edges.fit(s=0.01) edges.compute_contact_angle() # Display fig, axs = plt.subplots(2, 3, figsize=(15, 6.9), sharex=True, sharey=True) for i, ax in enumerate(axs.flat): plt.sca(ax) ind = int(i/5*(len(ims) - 1)) ims[ind]._display() edges[ind].display() plt.xlabel(\u0026#39;\u0026#39;) plt.ylabel(\u0026#39;\u0026#39;) plt.title(\u0026#39;t={:.2f}s\u0026#39;.format(ims.times[ind])) plt.xlim(0, 6.5) plt.ylim(0, 4.5) plt.show() Plotting the drop properties evolution We can then display a summary of the drop properties evolution. The following function will display: - the evolution of the drop edge contact with the surface (blue and yellow in the first figure) - the evolution of the drop base length (green in the first figure) - the evolution of the contact angles (blue and yellow in the second figure)\nedges.display_summary(figsize=(10, 8)) plt.show() Accessing the drop properties We can also extract the numeric values of those properties, if we want to do further processing on them.\nAngles are defined in the trigonometric sens, from the horizontal line. thetas, thetas_t = edges.get_contact_angles() print(\u0026#34;=== Left contact angle: ===\u0026#34;) print(thetas[:, 0]) print(\u0026#34;\\n=== Right contact angle: ===\u0026#34;) print(thetas[:, 1]) radius = edges.get_drop_base() print(\u0026#34;\\n=== Drop contact positions: ===\u0026#34;) print(radius) === Left contact angle: === [106.82124177 106.89153104 106.80195249 107.28297574 107.34363505 107.27784188 106.95177242 107.53012718 107.16280456 107.25262441 106.38800189 107.13128785 106.37357963 105.5870764 107.08325183 106.39480128 106.66051429 106.58224643 106.58062816 107.08964047 106.82985203 106.83611945 107.08110645 106.82104733 106.98000331 107.32906465 106.79129417 106.34451226 105.77145275 106.69374328 104.02426232 105.5866148 104.74019582 103.04931016 102.88969475 102.69842583 103.88329765 103.66657388] === Right contact angle: === [70.49951834 70.1299055 70.71083382 69.92671529 70.36612862 70.14270695 69.46986584 69.85713422 69.7853119 69.89271411 70.77508121 71.62557837 72.39170002 72.11318111 72.83302367 71.75478947 72.11059154 73.66624147 72.29808509 71.87726432 72.05937138 72.42824549 71.98435316 72.24383613 72.13157375 72.0712229 72.14669981 72.33741789 72.5867288 72.44292541 74.31487733 74.20368009 77.78053316 73.58388048 72.41755972 72.34645656 71.23826656 72.56089046] === Drop contact positions: === [[1.93832964 4.90852869] [1.9383381 4.90723033] [1.93861383 4.90483267] [1.93671908 4.90809455] [1.93600406 4.90858664] [1.93615952 4.9070416 ] [1.93634843 4.90952053] [1.93689621 4.90750024] [1.93664427 4.90404155] [1.93673364 4.90270441] [1.82986022 4.97697942] [1.66242062 5.1632435 ] [1.50391141 5.3317036 ] [1.37008729 5.45485383] [1.31325928 5.60250705] [1.12961601 5.61792064] [1.07022579 5.72288739] [1.08781048 5.84436594] [1.07971978 5.83596298] [1.07061923 5.83787147] [1.07040238 5.83480219] [1.07000855 5.83446575] [1.07021225 5.83108282] [1.07119756 5.83159342] [1.07091224 5.82816593] [1.07048666 5.82537719] [1.07006687 5.82606727] [1.07056253 5.82534949] [1.07072783 5.82771558] [1.14615126 5.76372021] [1.22834386 5.63496423] [1.3624827 5.50338496] [1.48844526 5.38162034] [1.59604399 5.25495474] [1.75512248 5.10651467] [1.83889684 5.0346689 ] [1.83687488 5.03739273] [1.83756333 5.03659173]]  "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/import-data/",
	"title": "Importing Data",
	"tags": [],
	"description": "Cookbook on importing data into Python",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n Ascii files Tables of numbers Simplest way to import data aranged in table from an ascii file is to use numpy:\nimport numpy as np data = np.genfromtxt(\u0026#39;data/data.csv\u0026#39;) print(data) [[37.70587485 25.87930691 11.1807849 6.29982498] [ 8.56702615 6.42440682 26.43331203 4.75911353] [46.62942399 30.2224285 49.35137806 16.32100564] [38.99391383 31.54382599 14.88671628 9.92786169] [15.50027605 48.45142251 30.16164798 18.29314173] [ 6.6336436 4.23085519 33.69157162 39.33629762] [ 3.64350001 0.61175817 18.83570963 13.17930294] [ 2.48434325 33.77391739 1.89173126 27.08342268] [15.48219208 49.78432857 48.17905851 35.66727198] [22.16530832 32.91388506 38.37315601 32.00800632] [32.5199885 45.86655672 12.45190816 33.92922999] [49.21332445 43.04899737 41.55144366 42.84145576] [37.2348323 33.27424985 1.9561426 46.64086924]]  Exporting arrays of numbers is as simple\nnew_data = data*4.3 np.savetxt(\u0026#39;data/new_data.csv\u0026#39;, new_data) Mixed table of numbers and text The pandas package allows to deal with complex sets of data including text and numbers.\nimport pandas as pd data = pd.read_csv(\u0026#39;data/data_mixed.csv\u0026#39;) print(data)  yellow 125 [0.18848372 0.54320351 0.1604927 ] 0 blue 24 [0.33882547 0.87313498 0.46219675] 1 red 93 [0.30873892 0.21764292 0.38400272] 2 grey 23 [0.5043959 0.548625 0.60459919]  Complex data Data than are not organized in a table (like text, result measurements from an exotic machine) can be imported using the builtins python functions.\nwith open(\u0026#39;data/data_complex.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: data = f.readlines() for line in data: print(line) From wikipedia: Python is an interpreted high-level programming language for general-purpose programming. Created by Guido van Rossum and first released in 1991, Python has a design philosophy that emphasizes code readability, and a syntax that allows programmers to express concepts in fewer lines of code,[25][26] notably using significant whitespace. It provides constructs that enable clear programming on both small and large scales.[27]  Images The scipy package makes it particularly easy to import on work with images.\nfrom scipy import misc image = misc.imread(\u0026#39;data/image.bmp\u0026#39;) /usr/lib/python3.6/site-packages/ipykernel_launcher.py:2: DeprecationWarning: `imread` is deprecated! `imread` is deprecated in SciPy 1.0.0, and will be removed in 1.2.0. Use ``imageio.imread`` instead.  Images can then be displayed it with matplotlib.\nimport matplotlib.pyplot as plt plt.figure() plt.imshow(image) plt.show() \u0026lt;matplotlib.figure.Figure at 0x7fbf6c3abba8\u0026gt;  Images are stored as arrays of numbers, so pixel values are easily accessible.\nprint(\u0026#34;Pixel values:\\n{}\u0026#34;.format(image)) print(\u0026#34;Value of the pixel at (10,10): {}\u0026#34;.format(image[10, 10])) Pixel values: [[180 186 191 ... 224 225 232] [192 180 179 ... 221 226 226] [184 186 185 ... 230 225 225] ... [ 30 30 30 ... 153 155 156] [ 29 28 28 ... 150 138 147] [ 26 26 28 ... 136 137 140]] Value of the pixel at (10,10): 189  Videos Coming soon\u0026hellip;\nExcel files Coming soon\u0026hellip;\nMatlab files Coming soon\u0026hellip;\nCompressed files Coming soon\u0026hellip;\n"
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/publication_quality_plots/",
	"title": "Publication-quality plots",
	"tags": [],
	"description": "Tutorial on making publication quality plot with Python and Matplotlib.",
	"content": "You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n Coming soon..."
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/",
	"title": "Python CookBook",
	"tags": [],
	"description": "",
	"content": " Python Cookbook This website provides a collection of Python scripts, snippets and tutorials for scientific data analysis. The currently available ressources are listed below:\n Drop Shape analysis using Python Tutorial for drop shape detection and analysis.\n  Drop Shape analysis using pyDSA (image) Tutorial for drop shape analysis using pyDSA on a single image.\n  Drop Shape analysis using pyDSA (video) Tutorial for drop shape analysis using pyDSA on a video.\n  Importing Data Cookbook on importing data into Python\n  Publication-quality plots Tutorial on making publication quality plot with Python and Matplotlib.\n  "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]