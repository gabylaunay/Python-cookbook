[
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/image-analysis/",
	"title": "Drop Shape analysis using Python",
	"tags": [],
	"description": "Tutorial for drop shape detection and analysis.",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n This tutorial proposes a way of analyzing the image of a drop on a SLIPS surface. At the end of it, we will have gathered the important characteristics of the drop:\n its edge its base radius the position of the triple (oil-drop-vapor) point the apparent contact angles  Preliminaries considerations During this tutorial, we will need several python packages that should be installed on your environment. The majority can be installed from PyPI using the following command:\npip install imageio matplotlib numpy scipy Or for conda users:\nconda install imageio matplotlib numpy scipy Opencv can be a bit more tricky. For conda users on windows, you should be able to get this working with the following command (untested):\nconda install opencv Importing images The Scipy package once provided a function to import image into python. Its documentation now recommends to use the Imageio package that supports plenty of file format (see here for an exhaustive list).\nImageio can also import video or grab images directly from a camera.\nimport imageio image = imageio.imread(\u0026#39;data/image.bmp\u0026#39;)   Explain me this block    We first imports the Imageio module.\nThen use its imread() function to read the image and store it in the image variable.\n   Images are stored as arrays of numbers. We can display them using the matplotlib package:\nimport matplotlib.pyplot as plt plt.figure() plt.imshow(image) plt.colorbar() plt.show()   Explain me this block    We first imports the pyplot module from matplotlib. The Pyplot module is the main module for easily plotting things in a Matlab-way.\nWe then create a figure with plt.figure(), display the image in it with plt.imshow(), add a colorbar with plt.colorbar() and show the results with plt.show()\n   Cropping As we can see on the previous image, the drop is centered on the image. A part of the syringe that was used to drop is also visible at the top.\nAs an edge detection performed on this image will certainly detect the syringe edges, it is a good idea to restrain the area of interest around the drop:\nimage = image[200:400, 200:550] plt.figure() plt.imshow(image) plt.show()    Explain me this block    The image variable is an array and can be cropped using indices. It is here cropped from indice 200 to 550 on the x axis and from 200 to 400 on the y axis. Because of the way image are referenced by the Imageio and matplotlib packages, the y axis (200:400) has to be specified first.\nWe then display the image.\n   Edge detection OpenCV (Open Source Computer Vision Library) is a very efficient library for image analysis that provides a python interface. We will use its edge detection functions to get the edge of our drop. More specifically, we will use the Canny edge detector.\nThis method necessitates to specify two threshold values. Those values have to be optimized depending on the nature/quality of the edges you want to detect. A first good guess is to take the minimal and maximal pixel values as thresholds.\nimport cv2 thres1 = image.min() thres2 = image.max() edges = cv2.Canny(image, thres1, thres2) # Display the obtained edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    We import opencv with import cv2.\nMinimal and maximal pixel values are obtained using the min() and max() methods and stored.\nThose values are then used as arguments of the edge detector: Canny().\nAnd the result is stored in the edge variable. We then display the detected edges.\n   The Canny() function returns an array of number that is equal to 1 (in yellow here) where edges have been detected.\nAs we can see here, OpenCV successfully detects the drop edges, but also some structures near the sample surface. Lets improve the threshold values to get rid of those unwanted bits.\nthres1 = image.min()*0.75 thres2 = image.max()*1.5 edges = cv2.Canny(image, thres1, thres2) # Display the obtained edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    The block is mainly similar to the previous one.\nThe threshold values have just been adjusted to get rid of the unwanted edges near the sample surface. The thresholds values are now 0.75 times the minimal pixel value and 1.5 times the maximal pixel value.\n   We get rid of some of the unwanted bits, but we still detect some edge due to the reflection of the drop on the sample. We can remove them by deleting all the edges present below the baseline, that is here toughly around y=180.\nedges[180:, :] = 0 # Display the obtained edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    edges is an array containing 1 where edges were detected. To remove edges for y\u0026lt;180, we just need to fill the array with 0 for y\u0026lt;180 with edges[180:, :] = 0.\n   From image to points Drop edge is for the moment stored as an image, if we want to access its coordinated, we need to find the pixel positions in space.\nThe numpy package can help us do that by detecting where the pixel values are not zero.\nimport numpy as np ys, xs = np.where(edges) ys = np.asarray(-ys, dtype=float) xs = np.asarray(xs, dtype=float) # Plot the edges plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show()   Explain me this block    We import numpy with import numpy as np.\nThe np.where() function return the positions of an array that are not zero. Here it then returns the position of the edges.\nThe two following lines allow to transform the position from integers to floating point values. This is needed for performing the fitting later on.\nplt.plot() allows to plot the edge points position.\nplt.axis('equal') ensures that the image is not deformed (stretched).\n   For convenience, we want to center the drop edge on the referential.\nxs -= xs.mean() ys -= ys.min() # Plot the edges plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show()   Explain me this block    xs.mean() allows to access the average position of the edges along x.\nys.min() allows to access the minimal position of the edges along y.\n   From pixels to mm We now know the edge position in pixel. To pass this information into millimeters, we just need to know the ratio between pixels and mm for our image.\nIt can be done by measuring the syringe diameter (here ~60 pixels) that we know is about 0.5mm. This give us our resolution of 120px/mm.\nWe then just need to scale our edge positions:\nres = 120 xs /= res ys /= res # Plot the edges plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.ylabel(\u0026#39;y [mm]\u0026#39;) plt.show() Fitting the edge Problem with the edge positions we obtained at this point is that they are at discrete positions (because extracted from an image). It is impossible as it to obtain contact angles or triple point position. We then have to find a good fitting of the drop edge on which we can work.\nThe Scipy package provide several ways of fitting data. Here, as we don\u0026rsquo;t care about the mathematical expression of our fitting, we will use a spline fitting.\nHowever, we need first to ensure that our edges points are sorted (strictly increasing x values).\n# Ensure increasing x values new_xs = np.sort(list(set(xs))) new_ys = [] for x in new_xs: new_ys.append(np.mean(ys[xs == x])) xs = new_xs ys = new_ys # Find a fit import scipy.interpolate as spint edge_f = spint.UnivariateSpline(xs, ys, k=5, s=0.001) # Display the fit plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.plot(xs, edge_f(xs)) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.ylabel(\u0026#39;y [mm]\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show() Getting the drop basic properties We can know extract some information from our data. It is quite straightforward to get the drop base radius and height:\nbase_radius = np.max(xs) - np.min(xs) height = np.max(ys) # Print print(\u0026#34;Base radius: {} mm\u0026#34;.format(base_radius)) print(\u0026#34;Drop height: {} mm\u0026#34;.format(height)) Base radius: 2.091666666666667 mm Drop height: 0.85 mm  Getting the contact angles "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/import-data/",
	"title": "Importing Data",
	"tags": [],
	"description": "Cookbook on importing data into Python",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n Ascii files Tables of numbers Simplest way to import data aranged in table from an ascii file is to use numpy:\nimport numpy as np data = np.genfromtxt(\u0026#39;data/data.csv\u0026#39;) print(data) [[37.70587485 25.87930691 11.1807849 6.29982498] [ 8.56702615 6.42440682 26.43331203 4.75911353] [46.62942399 30.2224285 49.35137806 16.32100564] [38.99391383 31.54382599 14.88671628 9.92786169] [15.50027605 48.45142251 30.16164798 18.29314173] [ 6.6336436 4.23085519 33.69157162 39.33629762] [ 3.64350001 0.61175817 18.83570963 13.17930294] [ 2.48434325 33.77391739 1.89173126 27.08342268] [15.48219208 49.78432857 48.17905851 35.66727198] [22.16530832 32.91388506 38.37315601 32.00800632] [32.5199885 45.86655672 12.45190816 33.92922999] [49.21332445 43.04899737 41.55144366 42.84145576] [37.2348323 33.27424985 1.9561426 46.64086924]]  Exporting arrays of numbers is as simple\nnew_data = data*4.3 np.savetxt(\u0026#39;data/new_data.csv\u0026#39;, new_data) Mixed table of numbers and text The pandas package allows to deal with complex sets of data including text and numbers.\nimport pandas as pd data = pd.read_csv(\u0026#39;data/data_mixed.csv\u0026#39;) print(data)  yellow 125 [0.18848372 0.54320351 0.1604927 ] 0 blue 24 [0.33882547 0.87313498 0.46219675] 1 red 93 [0.30873892 0.21764292 0.38400272] 2 grey 23 [0.5043959 0.548625 0.60459919]  Complex data Data than are not organized in a table (like text, result measurements from an exotic machine) can be imported using the builtins python functions.\nwith open(\u0026#39;data/data_complex.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: data = f.readlines() for line in data: print(line) From wikipedia: Python is an interpreted high-level programming language for general-purpose programming. Created by Guido van Rossum and first released in 1991, Python has a design philosophy that emphasizes code readability, and a syntax that allows programmers to express concepts in fewer lines of code,[25][26] notably using significant whitespace. It provides constructs that enable clear programming on both small and large scales.[27]  Images The scipy package makes it particularly easy to import on work with images.\nfrom scipy import misc image = misc.imread(\u0026#39;data/image.bmp\u0026#39;) /usr/lib/python3.6/site-packages/ipykernel_launcher.py:2: DeprecationWarning: `imread` is deprecated! `imread` is deprecated in SciPy 1.0.0, and will be removed in 1.2.0. Use ``imageio.imread`` instead.  Images can then be displayed it with matplotlib.\nimport matplotlib.pyplot as plt plt.figure() plt.imshow(image) plt.show() Images are stored as arrays of numbers, so pixel values are easily accesible\nprint(\u0026#34;Pixel values:\\n{}\u0026#34;.format(image)) print(\u0026#34;Value of the pixel at (10,10): {}\u0026#34;.format(image[10, 10])) Pixel values: [[180 186 191 ... 224 225 232] [192 180 179 ... 221 226 226] [184 186 185 ... 230 225 225] ... [ 30 30 30 ... 153 155 156] [ 29 28 28 ... 150 138 147] [ 26 26 28 ... 136 137 140]] Value of the pixel at (10,10): 189  "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/pydsa/",
	"title": "pydsa",
	"tags": [],
	"description": "",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n pyDSA is a python3 package for drop shape analaysis.\nInstallation To install pyDSA, download the sources here, extract, and install them:\npython3 setup.py install pyDSA have some dependencies (matplotlib, scipy, opencv, \u0026hellip;) that should be installed automatically.\nBasic usage for single images Importing image import pyDSA as dsa import matplotlib.pyplot as plt # Import an image im = dsa.import_from_image(\u0026#39;data/image.bmp\u0026#39;, dx=1/120, dy=1/120, unit_x=\u0026#39;mm\u0026#39;, unit_y=\u0026#39;mm\u0026#39;) # Display plt.figure() im.display() plt.show() Detecting edges im.crop(intervx=[1.5, 5], intervy=[1, 3], inplace=True) # Display plt.figure() im.display() plt.show() Set the baseline The interactive function im.choose_baseline() can be used to interactively set the baseline. It will display the drop and as you to put several point on the baseline by clicking on the image.\nHere we are gonna use the non-interactive function im.set_baseline().\nim.set_baseline([2, 1.61], [4.5, 1.61]) # Display plt.figure() im.display() plt.show() Detect the edges edge = im.edge_detection() # Display the edge plt.figure() edge.display() plt.show() Fit the edge edge.fit() # Display the edge plt.figure() edge.display() plt.show() Get the triple point edge.detect_triple_points() # Display the edge plt.figure() edge.display() plt.show() Get the angles edge.compute_contact_angle() # Display the edge plt.figure() edge.display() plt.show() Full script import pyDSA as dsa import matplotlib.pyplot as plt im = dsa.import_from_image(\u0026#39;data/image.bmp\u0026#39;, dx=1/120, dy=1/120, unit_x=\u0026#39;mm\u0026#39;, unit_y=\u0026#39;mm\u0026#39;) im.crop(intervx=[1.5, 5], intervy=[1, 3], inplace=True) im.set_baseline([2, 1.61], [4.5, 1.61]) edge = im.edge_detection() edge.fit() edge.detect_triple_points() edge.compute_contact_angle() # Display the edge plt.figure(figsize=(20, 8)) edge.display() im.display() plt.show() "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/pydsa_video/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/",
	"title": "Python CookBook",
	"tags": [],
	"description": "",
	"content": " Python Cookbook This website provides a collection of Python scripts, snippets and tutorials for scientific data analysis. The currently available ressources are listed below:\n Drop Shape analysis using Python Tutorial for drop shape detection and analysis.\n  Importing Data Cookbook on importing data into Python\n  pydsa You can get the python script detailled in this page here: script.py. And an archive containing the script and the data here: archive.tar.gz, archive.zip. pyDSA is a python3 package for drop shape analaysis. Installation To install pyDSA, download the sources here, extract, and install them: python3 setup.py install pyDSA have some dependencies (matplotlib, scipy, opencv, \u0026hellip;) that should be installed automatically. Basic usage for single images Importing image import pyDSA as dsa import matplotlib.\n   \n  "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]