[
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/image-analysis/",
	"title": "Drop Shape analysis using Python",
	"tags": [],
	"description": "Tutorial for drop shape detection and analysis.",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n This tutorial proposes a way of analyzing an image of a drop on a SLIPS surface. At the end of it, we will have gathered the important characteristics of the drop:\n its edge its base radius the position of the triple (oil-drop-vapor) point the apparent contact angles  Installation of the needed packages During this tutorial, we will need several python packages that need to be installed on your environment. The majority of the needed packages can be installed from PyPI using the following command:\npip install imageio matplotlib numpy scipy Or for conda users:\nconda install imageio matplotlib numpy scipy You will also need OpenCV to be installed. For conda users on windows, you should be able to get this working with the following command:\nconda install opencv Or this one:\nconda install -c menpo opencv Importing images Imageio package allows to import and export a variety of image format (see here for an exhaustive list).\nImageio can also import video or grab images directly from a camera.\nimport imageio image = imageio.imread(\u0026#39;data/image.bmp\u0026#39;)   Explain me this block    We first imports the Imageio module.\nThen use its imread() function to read the image and store it in the image variable.\n   Images are stored as arrays of numbers. We can display them using the matplotlib package:\nimport matplotlib.pyplot as plt plt.figure() plt.imshow(image) plt.colorbar() plt.show()   Explain me this block    We first imports the pyplot module from matplotlib. The Pyplot module is the main module for plotting data in a Matlab-way.\nWe then create a figure with plt.figure(), display the image in it with plt.imshow(), add a colorbar with plt.colorbar() and show the results with plt.show()\n   Cropping The drop is centered on the image, but a part of the syringe that was used to drop it is also visible at the top.\nAs an edge detection performed on this image will certainly detect the syringe edges, it is a good idea to restrain the area of interest around the drop.\nimage = image[200:400, 200:550] # Display plt.figure() plt.imshow(image) plt.show()    Explain me this block    The image variable is an array and can be cropped using indices. It is here cropped from indice 200 to 550 on the x axis and from 200 to 400 on the y axis. Because of the way image are referenced by the Imageio and matplotlib packages, the y axis has to be specified first.\nWe then display the image.\n   Edge detection OpenCV (Open Source Computer Vision Library) is a well-known library for image analysis that provides a python interface. We will use one of its edge detection functions to get the edge of our drop. More specifically, we will use the Canny edge detector.\nThis method necessitates to specify two threshold values, that have to be optimized depending on the nature/quality of the edges to detect. A first good guess is generally to take the minimal and maximal pixel values as thresholds.\nimport cv2 thres1 = image.min() thres2 = image.max() edges = cv2.Canny(image, thres1, thres2) # Display the obtained edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    We import opencv with import cv2.\nMinimal and maximal pixel values are obtained using the min() and max() methods and stored.\nThose values are then used as arguments of the OpenCV edge detector: Canny().\nThe result is stored in the edges variable, and displayed.\n   The Canny() function returns an array of number that is equal to 1 (in yellow here) where edges have been detected.\nOpenCV successfully detects the drop edges, but also some structures near the sample surface. Lets improve the threshold values to get rid of those unwanted bits.\nthres1 = image.min()*0.75 thres2 = image.max()*1.5 edges = cv2.Canny(image, thres1, thres2) # Display the obtained edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    The block is mainly similar to the previous one.\nThe threshold values are just adjusted to get rid of the unwanted edges near the sample surface. The thresholds values are now 0.75 times the minimal pixel value and 1.5 times the maximal pixel value.\n   We got rid of some of the unwanted bits, but we still detect some weird shapers due to the reflection of the drop on the sample. We can remove them by deleting all the edges present below the baseline, that is here toughly around y=180.\nedges[180:, :] = 0 # Display the obtained edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    edges is an array containing 1 where edges were detected. To remove edges for y\u0026lt;180, we just need to fill the array with 0 for y\u0026lt;180 with edges[180:, :] = 0.\n   From image to points Drop edge is for the moment stored as an image, if we want to access its coordinates, we need to find the positions of each non-null pixels (yellow pixels).\nThe numpy package can help us do that by detecting where the pixel values are not zero.\nimport numpy as np ys, xs = np.where(edges) ys = np.asarray(-ys, dtype=float) xs = np.asarray(xs, dtype=float) # Plot the edges plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show()   Explain me this block    We import numpy with import numpy as np.\nThe np.where() function returns the positions of the array that are not equal to zero. Which are here the positions of the edges.\nThe two following lines allow to transform the position from integers to floating point values. This is needed for the next steps.\nplt.plot() allows to plot the edge points position.\nplt.axis('equal') ensures that the image is not deformed (stretched).\n   For convenience, we want to center the drop edge on the referential.\nxs -= xs.mean() ys -= ys.min() # Plot the edges plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show()   Explain me this block    xs.mean() allows to access the average position of the edges along x.\nys.min() allows to access the minimal position of the edges along y.\n   From pixels to mm We now know the edge position in pixel. To pass this information into millimeters, we just need to know the ratio between pixels and mm for our image.\nIt can be done by measuring the syringe diameter (here ~60 pixels) that we know is about 0.5mm. This gives us a resolution of 120px/mm.\nWe then just need to scale our edge positions:\nres = 120 xs /= res ys /= res # Plot the edges plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.ylabel(\u0026#39;y [mm]\u0026#39;) plt.show() Fitting the edge Problem with the edge positions we obtained at this point is that they are at discrete positions (because extracted from an image). It is impossible as it to obtain contact angles or triple point position. In order to go further, we have to find a good fitting of the drop edge.\nThe Scipy package provides several ways of fitting data. Here, as we don\u0026rsquo;t care about the mathematical expression of our fitting, we will use a spline fitting.\nThe Scipy fitting function needs the data to be sorted (strictly increasing x values). We then need to fist ensure that our edges points are sorted.\n# Ensure increasing x values new_xs = np.sort(list(set(xs))) new_ys = [] for x in new_xs: new_ys.append(np.mean(ys[xs == x])) xs = new_xs ys = new_ys # Find a fit import scipy.interpolate as spint edge_f = spint.UnivariateSpline(xs, ys, k=5, s=0.005) # Display the fit plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.plot(xs, edge_f(xs)) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.ylabel(\u0026#39;y [mm]\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show()   Explain me this block    We first sort the drop edges position along x and put them in the new_xs variable.\nThen, for each value of x, we average the associated values of y, to ensure that there is only one value of y for each x.\nWe then perform the fitting using the UnivariateSpline function from Scipy.\nk and s parameters can be tuned to achieve smoother or more accurate fitting.\nWe then display the edge and its fitting.\n   Getting the drop basic properties We can know extract some information from our data. It is quite straightforward to get the drop base radius and height:\nbase_radius = np.max(xs) - np.min(xs) height = np.max(ys) # Print print(\u0026#34;Base radius: {} mm\u0026#34;.format(base_radius)) print(\u0026#34;Drop height: {} mm\u0026#34;.format(height)) Base radius: 2.091666666666667 mm Drop height: 0.85 mm  Getting the contact angles The contact angles are the angles done by our fitted curve where it meets the baseline (here y=0).\nleft_x = np.min(xs) right_x = np.max(xs) dx = (right_x - left_x)/100 # Left angle import scipy.misc as spmisc deriv = spmisc.derivative(edge_f, left_x, dx=dx) theta_left = np.arctan(deriv) # Right angle deriv = spmisc.derivative(edge_f, right_x, dx=dx) theta_right = np.pi + np.arctan(deriv) # Print print(theta_left/np.pi*180) print(theta_right/np.pi*180) # Display the fit plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.plot(xs, edge_f(xs)) plt.axhline(0, color=\u0026#39;k\u0026#39;) angle_len = .6 plt.plot([left_x, left_x + angle_len*np.cos(theta_left)], [edge_f(left_x), edge_f(left_x) + angle_len*np.sin(theta_left)]) plt.plot([right_x, right_x + angle_len*np.cos(theta_right)], [edge_f(right_x), edge_f(right_x) + angle_len*np.sin(theta_right)]) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.ylabel(\u0026#39;y [mm]\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show() 74.74264462928066 105.21597243751776    Explain me this block    We first determine the position of the drop edge contact with the baseline along x.\nWe then use the derivative function from Scipy to get the edges gradient at each contacts using the previous fitting.\ndx is used by the derivation algorithm. you can use a smaller value to get a more accurate result.\nThe edge gradients are then translated to angles.\nThe contact angle are then printed and displayed.\n   Getting the triple point Coming soon\u0026hellip;\n"
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/pydsa/",
	"title": "Drop Shape analysis using pyDSA (image)",
	"tags": [],
	"description": "Tutorial for drop shape analysis using pyDSA on a single image.",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n pyDSA is a python3 package for Drop Shape Analysis.\nInstalling pyDSA Dependencies You will first need to install IMTreatment by downloading the package here, extracting it and installing it with:\npython3 setup.py install pyDSA also use OpenCV as a dependency, so you will need it installed as well.\nInstall pyDSA Download the sources here, extract, and install them:\npython3 setup.py install pyDSA have some dependencies (matplotlib, scipy, numpy, \u0026hellip;) that should be installed automatically.\nImporting an image import pyDSA as dsa import matplotlib.pyplot as plt # Import an image im = dsa.import_from_image(\u0026#39;data/image.bmp\u0026#39;, dx=1/120, dy=1/120, unit_x=\u0026#39;mm\u0026#39;, unit_y=\u0026#39;mm\u0026#39;) # Display plt.figure() im.display() plt.show() Focusing on the drop im.crop(intervx=[1.5, 5], intervy=[1, 3], inplace=True) # Display plt.figure() im.display() plt.show() Setting the baseline The interactive function im.choose_baseline() can be used to interactively set the baseline. It will display the drop and ask you to put several baseline points by clicking on the image.\nHere we are gonna use the non-interactive function im.set_baseline().\nim.set_baseline([2, 1.61], [4.5, 1.61]) # Display plt.figure() im.display() plt.show() The baseline is automatically displayed as a green line on the drop image.\nDetecting the edges The drop edge is detected using the Canny edge detection algorithm from OpenCV.\nedge = im.edge_detection() # Display the edge plt.figure() edge.display() plt.show() If the edge detection is not good enough, the edge_detection function has several optional arguments that can help you get the edges you want. Please refer to the documentation of this function if you want to know more about this.\nFitting the edge Computing the contact angles will necessitates the edges to be fitted by a curve of some kind. pyDSA uses a spline to get a continuous definition of the drop edge.\nThe parameter s can be tuned to adapt the fitting. Small values of s mean more accurate fitting.\nedge.fit(s=0.0005) # Display the edge plt.figure() edge.display() plt.show() The edge fit is displayed in orange on top of the detected edge.\nDetecting the triple points In the case of a SLIPS surface, pyDSA can detect the triple point (triple point of contact between the oil, water and air). This is done by detecting the edge fit point of inflexion.\nedge.detect_triple_points() # Display the edge plt.figure() edge.display() plt.show() The triple points are displayed in purple on the detected edge.\nComputing the contact angles pyDSA uses the edge fitting to compute the contact angle at the contact between the drop and the baseline.\nIf triple points have been detected successfully, the apparent contact angle at the triple points are also computed.\nedge.compute_contact_angle() print(\u0026#39;Contact angles: {}\u0026#39;.format(edge.thetas)) print(\u0026#39;Triple point angles: {}\u0026#39;.format(edge.thetas_triple)) # Display the edge plt.figure() edge.display() plt.show() Contact angles: [48.90734602702736, 126.40314516490614] Triple point angles: [81.4670191340014, 96.86878969719106]  Full script import pyDSA as dsa import matplotlib.pyplot as plt im = dsa.import_from_image(\u0026#39;data/image.bmp\u0026#39;, dx=1/120, dy=1/120, unit_x=\u0026#39;mm\u0026#39;, unit_y=\u0026#39;mm\u0026#39;) im.crop(intervx=[1.5, 5], intervy=[1, 3], inplace=True) im.set_baseline([2, 1.61], [4.5, 1.61]) edge = im.edge_detection() edge.fit(s=0.0005) edge.detect_triple_points() edge.compute_contact_angle() # Display the edge plt.figure(figsize=(20, 8)) edge.display() im.display() plt.show() "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/pydsa_video/",
	"title": "Drop Shape analysis using pyDSA (video)",
	"tags": [],
	"description": "Tutorial for drop shape analysis using pyDSA on a video.",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n It is recommended to read the tutorial on using pyDSA on a single image before doing this tutorial.\nImporting a video Importing works in the same way than for an image. Importing images in Python can easily fill your memory, you can import only some images of the video by using the incr argument.\nimport pyDSA as dsa import matplotlib.pyplot as plt # Import an image ims = dsa.import_from_video(\u0026#39;data/video.mp4\u0026#39;, dx=1/120, dy=1/120, dt=1/10, unit_x=\u0026#39;mm\u0026#39;, unit_y=\u0026#39;mm\u0026#39;, unit_t=\u0026#39;s\u0026#39;, incr=1) # Display ims.display() plt.show() Detecting the edges and contact angles The method is similar than for a single image: setting the baseline, detecting the edges, fitting the edges, and computing the contact angles.\nims.set_baseline([0.0, 0.583], [6.492, 0.57]) edges = ims.edge_detection() edges.fit() edges.compute_contact_angle() # Display fig, axs = plt.subplots(2, 3, figsize=(15, 6.9), sharex=True, sharey=True) for i, ax in enumerate(axs.flat): plt.sca(ax) ind = int(i/5*(len(ims) - 1)) ims[ind]._display() edges[ind].display() plt.xlabel(\u0026#39;\u0026#39;) plt.ylabel(\u0026#39;\u0026#39;) plt.title(\u0026#39;t={:.2f}s\u0026#39;.format(ims.times[ind])) plt.xlim(0, 6.5) plt.ylim(0, 4.5) plt.show() Plotting the drop properties evolution You can then display a summary of the drop properties evolution.\nedges.display_summary(figsize=(10, 8)) plt.show() Accessing the drop properties Angles are defined in the trigonometric sens, from the horizontal.\nthetas, thetas_t = edges.get_contact_angles() print(\u0026#34;=== Left contact angle: ===\u0026#34;) print(thetas[:, 0]) print(\u0026#34;\\n=== Right contact angle: ===\u0026#34;) print(thetas[:, 1]) radius = edges.get_drop_base() print(\u0026#34;\\n=== Drop base: ===\u0026#34;) print(radius) === Left contact angle: === [107.23888862 107.37400597 107.05007046 106.86408573 107.09403969 106.87152793 106.89288488 107.58136308 106.87594673 107.19126851 106.7112947 105.7573553 108.49189273 107.93621437 108.02598317 106.22630943 105.39799791 107.07903966 107.56878519 106.39527947 105.81315002 106.46467088 106.25154551 106.26044864 106.23025799 106.62498501 105.91004866 105.93039563 105.74143665 107.00158745 106.8341172 105.38875097 104.60591926 103.55222994 103.38568201 103.69710654 104.54526798 104.28718362] === Right contact angle: === [69.81007431 70.06452567 69.94918814 70.46867058 69.86748429 69.78341881 70.00252248 69.35932262 68.97432279 69.70237737 71.18163723 72.69288788 73.16778647 70.7287935 71.19678366 71.79424 72.74553129 72.31503295 71.58481928 71.18967459 71.6835157 71.24023387 71.86786301 71.76356703 72.05721971 71.50635367 71.23118285 71.56113545 71.56776239 73.05972939 73.08250744 74.56329023 76.79512481 74.20533479 72.49144642 73.07689257 72.16620216 73.29188537] === Drop base: === [[1.92934707 4.88357022] [1.92939055 4.88213705] [1.9294059 4.87987593] [1.92838685 4.88230159] [1.92931732 4.88091349] [1.92864203 4.88004908] [1.92841013 4.88244095] [1.92819769 4.88182788] [1.92878161 4.87739426] [1.92828479 4.87678923] [1.8123559 4.96065597] [1.65386226 5.13711602] [1.49540105 5.30579731] [1.36169947 5.42793154] [1.31230875 5.57112045] [1.12948343 5.58552115] [1.0635439 5.69419133] [1.07904108 5.81586566] [1.07044106 5.80780901] [1.07149772 5.8031047 ] [1.07234249 5.79946514] [1.06430916 5.80621992] [1.06266364 5.80193666] [1.07190157 5.79594741] [1.06221319 5.80084337] [1.06262739 5.7994491 ] [1.06290811 5.79973602] [1.06261745 5.79818615] [1.07110155 5.79363283] [1.136702 5.73827396] [1.22100692 5.60771593] [1.35406724 5.47564621] [1.47956351 5.35478322] [1.58778352 5.22749747] [1.74789859 5.07840671] [1.82160408 5.01571592] [1.82934729 5.01013236] [1.82893682 5.00764041]]  "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/import-data/",
	"title": "Importing Data",
	"tags": [],
	"description": "Cookbook on importing data into Python",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n Ascii files Tables of numbers Simplest way to import data aranged in table from an ascii file is to use numpy:\nimport numpy as np data = np.genfromtxt(\u0026#39;data/data.csv\u0026#39;) print(data) [[37.70587485 25.87930691 11.1807849 6.29982498] [ 8.56702615 6.42440682 26.43331203 4.75911353] [46.62942399 30.2224285 49.35137806 16.32100564] [38.99391383 31.54382599 14.88671628 9.92786169] [15.50027605 48.45142251 30.16164798 18.29314173] [ 6.6336436 4.23085519 33.69157162 39.33629762] [ 3.64350001 0.61175817 18.83570963 13.17930294] [ 2.48434325 33.77391739 1.89173126 27.08342268] [15.48219208 49.78432857 48.17905851 35.66727198] [22.16530832 32.91388506 38.37315601 32.00800632] [32.5199885 45.86655672 12.45190816 33.92922999] [49.21332445 43.04899737 41.55144366 42.84145576] [37.2348323 33.27424985 1.9561426 46.64086924]]  Exporting arrays of numbers is as simple\nnew_data = data*4.3 np.savetxt(\u0026#39;data/new_data.csv\u0026#39;, new_data) Mixed table of numbers and text The pandas package allows to deal with complex sets of data including text and numbers.\nimport pandas as pd data = pd.read_csv(\u0026#39;data/data_mixed.csv\u0026#39;) print(data)  yellow 125 [0.18848372 0.54320351 0.1604927 ] 0 blue 24 [0.33882547 0.87313498 0.46219675] 1 red 93 [0.30873892 0.21764292 0.38400272] 2 grey 23 [0.5043959 0.548625 0.60459919]  Complex data Data than are not organized in a table (like text, result measurements from an exotic machine) can be imported using the builtins python functions.\nwith open(\u0026#39;data/data_complex.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: data = f.readlines() for line in data: print(line) From wikipedia: Python is an interpreted high-level programming language for general-purpose programming. Created by Guido van Rossum and first released in 1991, Python has a design philosophy that emphasizes code readability, and a syntax that allows programmers to express concepts in fewer lines of code,[25][26] notably using significant whitespace. It provides constructs that enable clear programming on both small and large scales.[27]  Images The scipy package makes it particularly easy to import on work with images.\nfrom scipy import misc image = misc.imread(\u0026#39;data/image.bmp\u0026#39;) /usr/lib/python3.6/site-packages/ipykernel_launcher.py:2: DeprecationWarning: `imread` is deprecated! `imread` is deprecated in SciPy 1.0.0, and will be removed in 1.2.0. Use ``imageio.imread`` instead.  Images can then be displayed it with matplotlib.\nimport matplotlib.pyplot as plt plt.figure() plt.imshow(image) plt.show() Images are stored as arrays of numbers, so pixel values are easily accesible\nprint(\u0026#34;Pixel values:\\n{}\u0026#34;.format(image)) print(\u0026#34;Value of the pixel at (10,10): {}\u0026#34;.format(image[10, 10])) Pixel values: [[180 186 191 ... 224 225 232] [192 180 179 ... 221 226 226] [184 186 185 ... 230 225 225] ... [ 30 30 30 ... 153 155 156] [ 29 28 28 ... 150 138 147] [ 26 26 28 ... 136 137 140]] Value of the pixel at (10,10): 189  "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/",
	"title": "Python CookBook",
	"tags": [],
	"description": "",
	"content": " Python Cookbook This website provides a collection of Python scripts, snippets and tutorials for scientific data analysis. The currently available ressources are listed below:\n Drop Shape analysis using Python Tutorial for drop shape detection and analysis.\n  Drop Shape analysis using pyDSA (image) Tutorial for drop shape analysis using pyDSA on a single image.\n  Drop Shape analysis using pyDSA (video) Tutorial for drop shape analysis using pyDSA on a video.\n  Importing Data Cookbook on importing data into Python\n  "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]