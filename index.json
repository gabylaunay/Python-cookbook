[
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/image-analysis/",
	"title": "Drop Shape analysis using Python",
	"tags": [],
	"description": "Tutorial for drop shape detection and analysis.",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n This tutorial proposes a way of analyzing an image of a drop on a SLIPS surface. At the end of it, we will have gathered the important characteristics of the drop:\n its edge its base radius the position of the triple (oil-drop-vapor) point the apparent contact angles  Installing the needed packages Basic packages During this tutorial, we will need several python packages that has to be installed on your environment. The majority of the needed packages can be installed from PyPI using the following command:\npip install imageio matplotlib numpy scipy Or for conda users:\nconda install imageio matplotlib numpy scipy OpenCV We will also need OpenCV to be installed. For conda users on windows, you should be able to get this working with the following command:\nconda install opencv Or this one:\nconda install -c menpo opencv For Linux users, get OpenCV from your distribution repository or build it from source.\nImporting images Imageio package allows to import and export a variety of image formats (see here for an exhaustive list).\nImageio can also import videos or grab images directly from cameras.\nimport imageio image = imageio.imread(\u0026#39;data/image.bmp\u0026#39;)   Explain me this block    We first imports the Imageio module.\nThen use its imread() function to read the image and store it in the image variable.\n   Images are stored as arrays of numbers. We can display them using the matplotlib package:\nimport matplotlib.pyplot as plt plt.figure() plt.imshow(image) plt.colorbar() plt.show()   Explain me this block    We first imports the pyplot submodule from matplotlib. The Pyplot module is the main submodule for plotting data in a Matlab-way.\nWe then create a figure with plt.figure(), display the image in it with plt.imshow(), add a colorbar with plt.colorbar() and show the results with plt.show().\nDepending on your IDE, you may not need the last line, as the figures will automatically be shown.\n   Cropping The drop is centered on the image, but a part of the syringe that was used to drop it is also visible at the top.\nAn edge detection performed directly on this image will certainly detect the syringe edges. To avoid that, we will restrain the area of interest around the drop.\nimage = image[200:400, 200:550] # Display plt.figure() plt.imshow(image) plt.show()    Explain me this block    The image variable is an array of numbers that can be cropped using indexes. It is here cropped from indexes 200 to 550 on the x axis and from indexes 200 to 400 on the y axis. Because of the way images are referenced by the Imageio and matplotlib packages, the y axis has to be specified first.\nWe then display the image.\n   Edge detection OpenCV (Open Source Computer Vision Library) is a well-known library for image analysis that provides a Python interface. We will use one of its edge detection functions to get the edge of our drop. More specifically, we will use the Canny edge detector.\nThis edge detector method necessitates to specify two threshold values, that have to be optimized depending on the nature/quality of the edges to detect. A first good guess is generally to take the minimal and maximal pixel values as thresholds.\nimport cv2 thres1 = image.min() thres2 = image.max() edges = cv2.Canny(image, thres1, thres2) # Display the edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    We import opencv with import cv2.\nMinimal and maximal pixel values are obtained using the min() and max() methods and stored.\nThose values are then used as arguments of the OpenCV edge detector: Canny().\nThe result is an array of numbers, stored in the edges variable.\nThis array of numbers id finally displayed.\n   The Canny() function returns an array of numbers that is equal to 1 (in yellow here) where edges have been detected, and 0 (in blue here) elsewhere.\nOpenCV successfully detects the drop edges, but also some structures near the sample surface. Lets improve the threshold values to get rid of those unwanted bits.\nSome methods, like the Otsu method, can be used to automatically infers good threshold values from an image. thres1 = image.min()*0.75 thres2 = image.max()*1.5 edges = cv2.Canny(image, thres1, thres2) # Display the edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    This block is mainly similar to the previous one.\nThe threshold values are just adjusted to get rid of the unwanted edges near the sample surface. The thresholds values are now 0.75 times the minimal pixel value and 1.5 times the maximal pixel value.\n   We got rid of some of the unwanted bits, but we still detect some weird shapes due to the reflection of the drop on the sample (around x=50, y=200 for example). We can remove them by deleting all the edges detected below the baseline, that is here roughly y=180.\nedges[180:, :] = 0 # Display the edges plt.figure() plt.imshow(edges) plt.show()   Explain me this block    edges is an array containing 1 where edges were detected and 0 elsewhere. To remove edges for y\u0026lt;180, we just need to fill the array with 0 for y\u0026lt;180.\nThis is done by specifying that the values of edges from y=180 to infinity (180:) and for every x (:) are set to 0.\n   From image to points Our drop edge is for the moment stored as an array of 0 and 1. If we want to access the edge coordinates, we need to find the positions of each pixel equal to 1 (yellow pixels here).\nThe numpy package can help us do that by detecting where the pixel values are not zero.\nimport numpy as np ys, xs = np.where(edges) ys = np.asarray(-ys, dtype=float) xs = np.asarray(xs, dtype=float) # Display the edges plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show()   Explain me this block    We import numpy with import numpy as np.\nThe np.where() function returns the positions of the array that are not equal to zero. Which are here the positions of our drop edge.\nThe two following lines allow to transform the position from integers to floating point values. This will be needed for the next steps.\nplt.plot() allows to plot the edge points position.\nplt.axis('equal') ensures that the image is not deformed (stretched) along x or y.\n   For convenience, we want to center the drop on the referential.\nxs = xs - xs.mean() ys = ys - ys.min() # Plot the edges plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show()   Explain me this block    xs.mean() allows to access the average position of the edges along x.\nys.min() allows to access the minimal position of the edges along y.\nBy substracting those values to x and y, we ensure that the origin of our referential is at the base of the drop.\n   From pixels to mm We achieved to get the edge coordinated in pixel. To pass this information into millimeters, we need to know the ratio between pixels and mm for our base image.\nIt can be done by measuring the syringe diameter (here ~60 pixels) that we know is about 0.5mm. This gives us a resolution of 120px/mm.\nWe can now scale our edge coordinates:\nres = 120 xs /= res ys /= res # Plot the edge fig, axs = plt.subplots(1, 2, figsize=(10, 4)) plt.sca(axs[0]) plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.ylabel(\u0026#39;y [mm]\u0026#39;) # Plot a zoom on the edge plt.sca(axs[1]) plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.xlim(-1.15, -0.9) plt.ylim(-0.05, 0.3) plt.title(\u0026#34;Zoom\u0026#34;) plt.show() Fitting the edge Problem with the edge coordinates we obtained at this point is that they are at discrete positions (because extracted from an image). It is impossible to obtain contact angles or triple point position from this kind of discretized data. In order to go further, we need to find a good fitting of the drop edge.\nThe Scipy package provides several ways of fitting different kind of data. Here, as we don\u0026rsquo;t care about the mathematical expression of our fitting, we will use a spline fitting: UnivariateSpline.\nThis fitting function needs the data to be sorted and with strictly increasing x values. Our edge coordinated need some transformation to fit those specifications.\n# Ensure increasing x values new_xs = np.sort(list(set(xs))) new_ys = [] for x in new_xs: new_ys.append(np.mean(ys[xs == x])) xs = new_xs ys = np.asarray(new_ys) # Fitting the drop edge import scipy.interpolate as spint edge_f = spint.UnivariateSpline(xs, ys, k=5, s=0.005) # Display the fit fig, axs = plt.subplots(1, 2, figsize=(10, 4)) plt.sca(axs[0]) plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.plot(xs, edge_f(xs)) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.ylabel(\u0026#39;y [mm]\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) # Plot a zoom on the edge plt.sca(axs[1]) plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.plot(xs, edge_f(xs)) plt.axhline(0, color=\u0026#39;k\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.xlim(-1.1, -0.7) plt.ylim(0, 0.5) plt.title(\u0026#34;Zoom\u0026#34;) plt.show()   Explain me this block    We first sort the drop edges position along x and put them in the new_xs variable.\nThen, for each value of x, we average the associated values of y, to ensure that there is only one value of y for each x.\nWe then perform the fitting using the UnivariateSpline function from Scipy.\nk and s parameters can be tuned to achieve smoother or more accurate fitting.\nWe then display the edge and its fitting.\n   Getting the drop basic properties We can now extract some information from our data, like the drop base length or the drop height:\nbase_radius = xs.max() - xs.min() height = ys.max() # Print print(\u0026#34;Drop base: {} mm\u0026#34;.format(base_radius)) print(\u0026#34;Drop height: {} mm\u0026#34;.format(height)) Drop base: 2.091666666666667 mm Drop height: 0.85 mm  Getting the contact angles The contact angles are the angles made by our fitted curve and the baseline (here y=0).\n# Get left and right contact points left_x = np.min(xs) right_x = np.max(xs) dx = (right_x - left_x)/100 # Left angle import scipy.misc as spmisc deriv = spmisc.derivative(edge_f, left_x, dx=dx) theta_left = np.arctan(deriv) # Right angle deriv = spmisc.derivative(edge_f, right_x, dx=dx) theta_right = np.pi + np.arctan(deriv) # Print print(theta_left/np.pi*180) print(theta_right/np.pi*180) # Display the fit and the angles plt.figure() plt.plot(xs, ys, marker=\u0026#39;o\u0026#39;, ls=\u0026#39;none\u0026#39;) plt.plot(xs, edge_f(xs)) plt.axhline(0, color=\u0026#39;k\u0026#39;) angle_len = .6 plt.plot([left_x, left_x + angle_len*np.cos(theta_left)], [edge_f(left_x), edge_f(left_x) + angle_len*np.sin(theta_left)]) plt.plot([right_x, right_x + angle_len*np.cos(theta_right)], [edge_f(right_x), edge_f(right_x) + angle_len*np.sin(theta_right)]) plt.xlabel(\u0026#39;x [mm]\u0026#39;) plt.ylabel(\u0026#39;y [mm]\u0026#39;) plt.axis(\u0026#39;equal\u0026#39;) plt.show() 74.74264462928066 105.21597243751776    Explain me this block    We first determine the positions of the drop edge contact with the baseline along x.\nWe then use the derivative function from Scipy to get the edge local slope at each contacts using our fitting.\ndx is used by the derivation algorithm. you can use a smaller value to get a more accurate result.\nThe edge local gradients are then translated to angles.\nWe then print and display the contact angles.\n   Getting the triple point Coming soon\u0026hellip;\n"
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/pydsa/",
	"title": "Drop Shape analysis using pyDSA (image)",
	"tags": [],
	"description": "Tutorial for drop shape analysis using pyDSA on a single image.",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n pyDSA is a python3 package for Drop Shape Analysis.\nInstalling pyDSA Dependencies You will first need to install IMTreatment by downloading the package here, extracting it and installing it with:\npython3 setup.py install pyDSA also use OpenCV for edge detection, so you will need it installed as well.\nInstall pyDSA Download the sources here, extract, and install them:\npython3 setup.py install pyDSA have some dependencies (matplotlib, scipy, numpy, \u0026hellip;) that should be installed automatically.\nImporting an image import pyDSA as dsa import matplotlib.pyplot as plt plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = 15, 9 # Import an image im = dsa.import_from_image(\u0026#39;data/image.bmp\u0026#39;, dx=1/120, dy=1/120, unit_x=\u0026#39;mm\u0026#39;, unit_y=\u0026#39;mm\u0026#39;) # Display it plt.figure() im.display() plt.show() Scaling Here we scaled the image during the import (using the dx and dy parameters), but you can also scale the image afterwards, using the im.scale_interactive() interactive function.\nThis function ask you to select two points on the image and to input the real distance (in mm for example) separating them. It then scale the image accordingly.\nThe scaling is then stored in an .info file alongside the image, and will be automatically imported the next time you want to work with this image.\nFocusing on the drop im.crop(intervx=[1.5, 5], intervy=[1, 3], inplace=True) # Display plt.figure() im.display() plt.show() Setting the baseline pyDSA provides an interactive function im.choose_baseline() to interactively set the baseline. It will display the drop image and ask you to put baseline points by clicking on the image.\nHere, we are gonna use the non-interactive function im.set_baseline() to set the baseline.\nim.set_baseline(pt1=[2, 1.61], pt2=[4.5, 1.61]) # Display plt.figure() im.display() plt.show() The baseline is automatically displayed as a blue line on the drop image.\nLike the scaling, the baseline position is stored in the .info file, and automatically loaded.\nDetecting the edges The drop edge is detected using the Canny edge detection algorithm from OpenCV.\nedge = im.edge_detection() # Display the edge plt.figure() im.display() edge.display() plt.show() If the edge detection is not good enough, the edge_detection function provides several optional arguments that can help you get the edges you want. Please refer to the inline documentation of this function if you want to know more about this.\nAnother method, that detects the edges from contour map is also available:\nedge_cont = im.edge_detection_contour(level=.25) # Display the edge plt.figure() im.display() edge_cont.display() plt.show() Fitting the edge Computing the contact angles will necessitates the edges to be fitted by a curve of some kind. pyDSA provide several ways of doing that, depending if you are studying a drop on a dry surface:\n Circle fitting Ellipse fitting Polynomial fitting Spline fitting  or a drop on a lubricated surface: - Polynomial fitting - Spline fitting - Circles fitting\nCircle fitting The drop edges are fitted with a circle. This solution is only usable for small drop deposited on surfaces.\ncfit = edge.fit_circle() # Display the edge plt.figure() im.display() cfit.display() plt.show() Ellipse fitting The drop edges are fitted with an ellipse. This solution is generally good, as soon as the drop is on a dry surface. It also generally gives less scattered contact angles than the spline fitting.\nelfit = edge.fit_ellipse() # Display the edge plt.figure() im.display() elfit.display() plt.show() Polynomial fitting Fit the drop edges with a polynomial of the wanted degree (default is 3). Low degrees are particularly fitted for drops on dry surfaces, but that cannot be properly fitted with a circle or an ellipse. High degrees can be used for drops on SLIPS surfaces.\npfit = edge.fit_polyline(deg=5) # Display the edge plt.figure() im.display() pfit.display() plt.show() Spline fitting The drop edges are fitted with two splines. This solution is relatively generic and should work for any kind of drops.\nsfit = edge.fit_spline() # Display the edge plt.figure() im.display() sfit.display() plt.show() The edge fitting is displayed in orange.\nSpline fittings allow to detect the position of the triple point if present, using the sfit.detect_triple_points().\nMultiple circles fitting This method fits three circles to the drop edges: one for the drop and two for the wetting ridges. This method is only valid for drops on lubricated surfaces.\nAs the present image does not present well-defined wetting ridges, the follwing result is just provided as an illustration.\ncsfit = edge_cont.fit_circles(triple_pts=[[2.1, 1.7], [4.2, 1.7]]) # Display the edge plt.figure() im.display() csfit.display() plt.show() Computing the contact angles Any of the previously presented fitting can be used to compute the contact angles of the drop. If a triple point is present, the contact angles at the triple points are also computed.\nelfit.compute_contact_angle() print(\u0026#39;Contact angles: {}\u0026#39;.format(elfit.thetas)) # Display the edge fig, axs = plt.subplots(1, 2, figsize=(13, 4)) plt.sca(axs[0]) im.display() elfit.display() plt.ylim(1.5, 3) # Zoom plt.sca(axs[1]) im.display() elfit.display() plt.ylim(1.5, 2) plt.xlim(1.8, 2.4) plt.show() Contact angles: [86.7804831 93.08146878]  Dealing with videos pyDSA can directly import videos and automatically analyze them in batch. This is the subject of the tutorial available here.\nHow does it works ? If you want to know more about how pyDSA works, you can take a look at the drop shape analysis tutorial, or go through the code (on your machine, or here).\n"
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/pydsa_video/",
	"title": "Drop Shape analysis using pyDSA (video)",
	"tags": [],
	"description": "Tutorial for drop shape analysis using pyDSA on a video.",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n It is recommended to read the tutorial on using pyDSA on a single image before doing this tutorial. This tutorial presents how to use pyDSA to analyze videos of drops. The video used is a side-view of a drop during an inflation-deflation sequence.\nImporting a video Importing works in the same way than for an image.\nimport pyDSA as dsa import matplotlib.pyplot as plt plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = 15, 9 # Import an image ims = dsa.import_from_video(\u0026#39;data/video.mp4\u0026#39;, dx=1/120, dy=1/120, dt=1/10, unit_x=\u0026#39;mm\u0026#39;, unit_y=\u0026#39;mm\u0026#39;, unit_t=\u0026#39;s\u0026#39;, incr=10) # Display ims.display() plt.show() Scaling As for an image, you can specify the scaling during the import (as it is done here), or by using the interactive function ims.scale_interactive().\nDetecting the edges and contact angles The method is similar than for a single image: we set the baseline, detect the edges, fit the edges, and compute the contact angles.\nAs presented in the pyDSA image tutorial, different type of fittings are available: - Spline - Polynomial - Circle - Ellipse - Multiple circles\nWe will be using the spline fitting here:\nims.set_baseline([0.0, 0.583], [6.492, 0.57]) edges = ims.edge_detection() fits = edges.fit_spline() fits.compute_contact_angle() # Display fig, axs = plt.subplots(2, 3, figsize=(15, 6.9), sharex=True, sharey=True) for i, ax in enumerate(axs.flat): plt.sca(ax) ind = int(i/5*(len(ims) - 1)) ims[ind]._display() fits[ind].display() plt.xlabel(\u0026#39;\u0026#39;) plt.ylabel(\u0026#39;\u0026#39;) plt.title(\u0026#39;t={:.2f}s\u0026#39;.format(ims.times[ind])) plt.xlim(0, 6.5) plt.ylim(0, 4.5) plt.show() Plotting the drop properties evolution We can then display a summary of the drop properties evolution. The following function will display: - the evolution of the drop edge contact with the surface (blue and yellow in the first figure) - the evolution of the drop base length (green in the first figure) - the evolution of the contact angles (blue and yellow in the second figure)\nfits.display_summary(figsize=(10, 8)) plt.show() Accessing the drop properties We can also extract the numeric values of those properties, if we want to do further processing on them.\nAngles are defined in the trigonometric sens, from the horizontal line. thetas = fits.get_contact_angles() print(\u0026#34;=== Left contact angle: ===\u0026#34;) print(thetas[:, 0]) print(\u0026#34;\\n=== Right contact angle: ===\u0026#34;) print(thetas[:, 1]) radius = fits.get_base_diameter() print(\u0026#34;\\n=== Drop base diameter: ===\u0026#34;) print(radius) === Left contact angle: === [107.12413524 107.2256323 106.8389965 107.61289737 107.51142226 107.57276364 105.62953427 105.23144587 107.55277592 107.66401919 108.77097434 108.52915265 108.19716091 108.86385993 108.45840366 108.11872607 107.43318801 107.37802132 106.76612957 107.92113095 107.57457138 107.64618411 107.7956656 107.61428678 107.77428584 107.89692038 107.43138843 107.37972004 106.70456297 107.6173274 106.97438733 108.39064801 108.09762817 105.66737104 104.35097272 105.53252132 106.82710145 106.41737082] === Right contact angle: === [71.15835736 70.62338871 72.12690458 71.10917987 71.46088435 71.19212707 71.00712376 71.19449554 70.45508103 72.29992073 71.45324263 70.65348578 71.07857174 69.86998847 71.54808159 71.27592401 71.19708308 71.25220752 72.14233178 71.25019314 71.4840981 71.70291529 71.63233732 71.36244349 71.13926384 72.04490637 71.6763298 71.69389988 71.84434718 72.03632988 72.27500458 70.6757763 72.51274596 72.29308195 74.57313961 75.53117754 72.90092722 72.94096946] === Drop base diameter: === [2.77271942 2.77111709 2.77227161 2.76712496 2.76621241 2.76469889 2.76344687 2.76218082 2.75825678 2.75989665 2.95207377 3.30542341 3.64034989 3.89385347 4.0979318 4.29631274 4.46354555 4.57597189 4.58054252 4.57492919 4.57553313 4.57364276 4.57366044 4.57150138 4.57028073 4.57106973 4.56997315 4.568663 4.56926576 4.4437705 4.23165626 3.96518912 3.73062331 3.48558824 3.20130726 3.04153762 3.02750285 3.02485214]  "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/import-data/",
	"title": "Importing Data",
	"tags": [],
	"description": "Cookbook on importing data into Python",
	"content": " You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n Ascii files Tables of numbers Simplest way to import data aranged in table from an ascii file is to use numpy:\nimport numpy as np data = np.genfromtxt(\u0026#39;data/data.csv\u0026#39;) print(data) [[37.70587485 25.87930691 11.1807849 6.29982498] [ 8.56702615 6.42440682 26.43331203 4.75911353] [46.62942399 30.2224285 49.35137806 16.32100564] [38.99391383 31.54382599 14.88671628 9.92786169] [15.50027605 48.45142251 30.16164798 18.29314173] [ 6.6336436 4.23085519 33.69157162 39.33629762] [ 3.64350001 0.61175817 18.83570963 13.17930294] [ 2.48434325 33.77391739 1.89173126 27.08342268] [15.48219208 49.78432857 48.17905851 35.66727198] [22.16530832 32.91388506 38.37315601 32.00800632] [32.5199885 45.86655672 12.45190816 33.92922999] [49.21332445 43.04899737 41.55144366 42.84145576] [37.2348323 33.27424985 1.9561426 46.64086924]]  Exporting arrays of numbers is as simple\nnew_data = data*4.3 np.savetxt(\u0026#39;data/new_data.csv\u0026#39;, new_data) Mixed table of numbers and text The pandas package allows to deal with complex sets of data including text and numbers.\nimport pandas as pd data = pd.read_csv(\u0026#39;data/data_mixed.csv\u0026#39;) print(data)  yellow 125 [0.18848372 0.54320351 0.1604927 ] 0 blue 24 [0.33882547 0.87313498 0.46219675] 1 red 93 [0.30873892 0.21764292 0.38400272] 2 grey 23 [0.5043959 0.548625 0.60459919]  Complex data Data than are not organized in a table (like text, result measurements from an exotic machine) can be imported using the builtins python functions.\nwith open(\u0026#39;data/data_complex.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: data = f.readlines() for line in data: print(line) From wikipedia: Python is an interpreted high-level programming language for general-purpose programming. Created by Guido van Rossum and first released in 1991, Python has a design philosophy that emphasizes code readability, and a syntax that allows programmers to express concepts in fewer lines of code,[25][26] notably using significant whitespace. It provides constructs that enable clear programming on both small and large scales.[27]  Images The scipy package makes it particularly easy to import on work with images.\nfrom scipy import misc image = misc.imread(\u0026#39;data/image.bmp\u0026#39;) /usr/lib/python3.6/site-packages/ipykernel_launcher.py:2: DeprecationWarning: `imread` is deprecated! `imread` is deprecated in SciPy 1.0.0, and will be removed in 1.2.0. Use ``imageio.imread`` instead.  Images can then be displayed it with matplotlib.\nimport matplotlib.pyplot as plt plt.figure() plt.imshow(image) plt.show() \u0026lt;matplotlib.figure.Figure at 0x7fbf6c3abba8\u0026gt;  Images are stored as arrays of numbers, so pixel values are easily accessible.\nprint(\u0026#34;Pixel values:\\n{}\u0026#34;.format(image)) print(\u0026#34;Value of the pixel at (10,10): {}\u0026#34;.format(image[10, 10])) Pixel values: [[180 186 191 ... 224 225 232] [192 180 179 ... 221 226 226] [184 186 185 ... 230 225 225] ... [ 30 30 30 ... 153 155 156] [ 29 28 28 ... 150 138 147] [ 26 26 28 ... 136 137 140]] Value of the pixel at (10,10): 189  Videos Coming soon\u0026hellip;\nExcel files Coming soon\u0026hellip;\nMatlab files Coming soon\u0026hellip;\nCompressed files Coming soon\u0026hellip;\n"
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/publication_quality_plots/",
	"title": "Publication-quality plots",
	"tags": [],
	"description": "Tutorial on making publication quality plot with Python and Matplotlib.",
	"content": "You can get the python script detailled in this page here: script.py.\nAnd an archive containing the script and the data here: archive.tar.gz, archive.zip.\n Coming soon..."
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/",
	"title": "Python CookBook",
	"tags": [],
	"description": "",
	"content": " Python Cookbook This website provides a collection of Python scripts, snippets and tutorials for scientific data analysis. The currently available ressources are listed below:\n Drop Shape analysis using Python Tutorial for drop shape detection and analysis.\n  Drop Shape analysis using pyDSA (image) Tutorial for drop shape analysis using pyDSA on a single image.\n  Drop Shape analysis using pyDSA (video) Tutorial for drop shape analysis using pyDSA on a video.\n  Importing Data Cookbook on importing data into Python\n  Publication-quality plots Tutorial on making publication quality plot with Python and Matplotlib.\n   \n  "
},
{
	"uri": "https://gabylaunay.github.io/Python-cookbook/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]